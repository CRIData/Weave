<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<!--
SchafersMissingDataImputation

1. Pick your columns
2. Assign variable names to those columns
3. Input an R script using those variable names
4. List the outputs you want
5. The columns get joined on the client-side using the keys (record identifiers) to produce flat Arrays lined up by row index
6. These columns become the input to the R script on the server, the server runs the script and returns the results.
7. On the client side, any returned Arrays are matched up with the original keys using the same row order to become columns.
8. Any other results are just printed out to the text area.

@spurushe

-->
<DraggablePanel xmlns="weave.ui.*" xmlns:mx="http://www.adobe.com/2006/mxml" 
				horizontalScrollPolicy="off" verticalScrollPolicy="off"
				title="Schafers Missing Data Imputation"
				x="15%" width="70%" y="15%" height="70%"
				backgroundColor="#EFF4BC" 
				layout="horizontal"
				autoLayout="true" implements="weave.api.ui.IVisTool"
				>
	<mx:HBox width="100%" height="100%" paddingLeft="{padding}" paddingRight="{padding}" paddingTop="{padding}" paddingBottom="{padding}">
		<mx:VBox width="20%" height="100%" verticalGap="0">
			<mx:Label text="(1) Select data to use in your script"/>
			<ColumnListComponent id="inputColumnList" label="Input columns" hashMap="{variables}" width="100%" height="100%"   />			
		</mx:VBox>
		<mx:VBox  id="vb" width="45%" height="100%" verticalGap="0">
			<LabelWithWordWrap text="(2)Assign variable names and check Attributes for Missing Data"/>
			<mx:TextArea id = "assignTA" width="100%" height="100%" wordWrap="false"/>
			<mx:Spacer height="{padding}"/>
			
			<mx:Spacer height="{padding}"/>
			<mx:Button id="checkforNA" label="Impute Missing Data" buttonDown= "imputing_buttonDownHandler(event)"/>
		
			<mx:Spacer height="{padding}"/>
			
			
			<LabelWithWordWrap text="(6) Run your script on the server"/>
			<mx:HBox>
				<!--mx:Button id="B2" label="Run script"  buttonDown="viewAndSendbuttonClickHandler()"/-->
				<mx:CheckBox id="intermediateResultCB" label="Verbose" toolTip="Show intermediate results from R"/>
				<mx:CheckBox id="warningCB" label="Warnings" toolTip="Show warnings from R"/>
			</mx:HBox>
			
			<mx:Spacer height="{padding}"/>
		
	</mx:VBox>
	</mx:HBox>	
	<mx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.controls.DataGrid;
			import mx.controls.Image;
			import mx.controls.dataGridClasses.DataGridColumn;
			import mx.events.FlexEvent;
			import mx.rpc.AsyncToken;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.utils.ObjectUtil;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.api.ui.IVisTool;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableString;
			import weave.core.weave_internal;
			import weave.data.AttributeColumns.CSVColumn;
			import weave.data.AttributeColumns.StringColumn;
			import weave.data.DataSources.CSVDataSource;
			import weave.data.KeySets.KeySet;
			import weave.services.DelayedAsyncResponder;
			import weave.services.WeaveRServlet;
			import weave.services.beans.RResult;
			import weave.utils.ColumnUtils;
			import weave.utils.ResultUtils;
			import weave.utils.VectorUtils;
			import weave.visualization.tools.DataTableTool;
			import weave.visualization.tools.SimpleVisTool;
			
			
			WeaveAPI.registerImplementation(IVisTool, SchafersMissingDataTool);
			
			private const padding:int = 5;
			
			private static function get selection():KeySet
			{
				return Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			}
			
			public const variables:LinkableHashMap = registerLinkableChild(this, new LinkableHashMap(IAttributeColumn));
			private var Rservice:WeaveRServlet = new WeaveRServlet(Weave.properties.rServiceURL.value);
			public const inputTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			public const outputTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			public const assignTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			
			
			override protected function constructor():void
			{
				super.constructor();				
				var columns:Array = SimpleVisTool.getDefaultColumnsOfMostCommonKeyType();
				for (var i:int = 0; i < columns.length; i++)
					variables.requestObjectCopy(null, columns[i]);
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				/* linkBindableProperty(outputTALinkable,outputTA,"text"); */
				linkBindableProperty(assignTALinkable,assignTA,"text");
			}
			
			/**
			 * @return A multi-dimensional Array like [keys, [data1, data2, ...]] where keys implement IQualifiedKey
			 */
			private function joinColumns(columns:Array):Array
			{
				var keys:Array = selection.keys.length > 0 ? selection.keys : null;
				//make dataype Null, so that columns will be sent as exact dataype to R
				//if mentioned as String or NUmber ,will convert all columns to String or Number .
				var result:Array = ColumnUtils.joinColumns(columns,null, true, keys);
				return [result.shift(),result];
			}
		
			[Bindable]
			private var finalCollection:ArrayCollection = new ArrayCollection();
			
			private var headings:Array = new Array();
			//private var currentDataGrid:DataGrid = null;
			
			private function handleRunScriptResult(event:ResultEvent, token:Object = null):void
			{
				var finalReturnedRColumns:Array = new Array();
				var missingRecordNumber:Array = new Array();
				/* This is the final array added as a CSVDataSource having structure
				[
					["k","x","y","z"]
					["k1",1,2,3]
					["k2",3,4,6]
					["k3",2,4,56]
				] */
			
				//Object to stored returned result - Which is array of object{name: , value: }
				var Robj:Array = event.result as Array;
				
				
				if (Robj == null)
				{
					reportError("R Servlet did not return an Array of results as expected.");
					return;
				}
				
				//Collecting all RResult Objects into an Array 
				var RresultArray:Array = new Array();
				
				//collecting Objects of type RResult(Should Match result object from Java side)
				for (var i:int = 0; i < (event.result).length; i++)
				{
					if (Robj[i] == null)
					{
						trace("WARNING! R Service returned null in results array at index "+i);
						continue;
					}
					var rResult:RResult = new RResult(Robj[i]);
					RresultArray.push(rResult);	
					
					
				}	
				
				//We copy the object, one to be used for displaying Imputed Columns, the other to create the CSVDatasource
				var imputedValuesForDisplay:Object = ObjectUtil.copy(RresultArray);
				//finalCollection = fillingMissingDataNumber(headings, RresultArray[0].value);
				
				//missingDataGrid.dataProvider = finalCollection;
				
				/**
				 * Creating a new Datatable tool
				 **/
				
				var dataTB:DataTableTool = Weave.root.requestObject(null,DataTableTool,false);
				dataTB.title = dataTB.title + "Original and Imputed Columns";
				
				//To make availabe for Weave -Mapping with key returned from Token
				var keys:Array = token as Array;
				
				missingRecordNumber = RresultArray[0].value;
				finalReturnedRColumns = RresultArray[1].value;
				
				/* Creates the final array, stated above, for CSVDatasource
				Keys used from token
				We use the localName property because otherwise it casts the same key for all the values and thus 
				each key is not unique
				*/
				for (var c:int = 0; c < keys.length; c++)
					
					{
						finalReturnedRColumns[c].unshift(missingRecordNumber[c]);
						finalReturnedRColumns[c].unshift(keys[c].localName);
					}
				
				
				
			     finalReturnedRColumns.unshift(columnNames);
				 
				 //Give it a unique name incase we need to store the columns from multiple imputations
				 var name:String = Weave.root.generateUniqueName("ImputedColumns");
				 var imputedCsvDataSource:CSVDataSource = Weave.root.requestObject(name,CSVDataSource,false);
				 imputedCsvDataSource.setCSVData(finalReturnedRColumns);
				 imputedCsvDataSource.keyType.value = (keys[0] as IQualifiedKey).keyType;
				 imputedCsvDataSource.keyColName.value = "Key";
				
				//Objects "(object{name: , value:}" are mapped whose value length that equals Keys length
				for (var p:int = 0;p < RresultArray.length; p++)
				{
					if(RresultArray[p].value is Array){
						if(keys){
							if ((RresultArray[p].value).length == keys.length){
								if (RresultArray[p].value[0] is String)	{
									var testStringColumn:StringColumn = Weave.root.requestObject(RresultArray[p].name, StringColumn, false);
									var keyVec:Vector.<IQualifiedKey> = new Vector.<IQualifiedKey>();
									var dataVec:Vector.<String> = new Vector.<String>();
									VectorUtils.copy(keys, keyVec);
									VectorUtils.copy(Robj[p].value, dataVec);
									testStringColumn.setRecords(keyVec, dataVec);
									if (keys.length > 0)
										testStringColumn.weave_internal::metadata.@keyType = (keys[0] as IQualifiedKey).keyType;
									testStringColumn.weave_internal::metadata.@name = RresultArray[p].name;
								}
								else{
									var table:Array = [];
									for (var k:int = 0; k < keys.length; k++)
										table.push([ (keys[k] as IQualifiedKey).localName, Robj[p].value[k] ]);
									
									//testColumn are named after respective Objects Name (i.e) object{name: , value:}
									var testColumn:CSVColumn = Weave.root.requestObject(RresultArray[p].name, CSVColumn, false);
									testColumn.keyType.value = keys.length > 0 ? (keys[0] as IQualifiedKey).keyType : null;
									testColumn.numericMode.value = true;
									testColumn.csvData.value = WeaveAPI.CSVParser.createCSV(table);
									testColumn.title.value = RresultArray[p].name;
								}
							}
						}						
					}										
				}
			}
			
			private function handleRunScriptFault(event:FaultEvent, token:Object = null):void
			{
				trace(["fault", token, event.message].join('\n'));
				reportError(event);
			}
			
			/* protected function assignTA_clickHandler(event:MouseEvent):void
			{
				var selectedTA:TextArea = (focusManager.getFocus()) as TextArea;
				focusedTA = selectedTA;
			}  */
			
			
			private var assignToBeValues:Array = new Array();
			private var ar:ArrayCollection = new ArrayCollection();
			private var columnNames:Array = new Array();//stores the names of the columns (an array of strings)
			
			protected function imputing_buttonDownHandler(event:FlexEvent):void
			{
				
				var result:Array = new Array();
				var joinedColumnQKeys:Array; //Columns from Joined columns Method
				var joinedColumns:Array;
		    	var selectedColumns:Array = variables.getObjects(); //Columns from ColumnListComponent 
				
				var attributeColumns:Array = new Array();
				//Use as Attribute column as joinColumns takes members of IAttributeColumn
				for(var i:int = 0; i<selectedColumns.length; i++)
				{
					attributeColumns[i] = selectedColumns[i] as IAttributeColumn;
					columnNames[i] = ColumnUtils.getTitle(attributeColumns[i]);
				}
				columnNames.unshift("NoOfMissingR");
				columnNames.unshift("Key");
				//joinColumns Called only When columns are added to ColumnListComponent
				
				if(selectedColumns.length >0)
				{					
					// get records for keys common to all columns 
					result = joinColumns(attributeColumns);
					joinedColumnQKeys = result[0];
					joinedColumns = result[1];
					
				}
				
				assignToBeValues = joinedColumns;
				
				//variable names for the columns to be used in R
				 var RscriptAssignNames:String = assignTA.text;//as complete string
				
				//broken into individual variable names
				var assignNames:Array = VectorUtils.flatten(WeaveAPI.CSVParser.parseCSV(assignTA.text));
				
				
				headings = assignNames;//to get the headings for the missing data columns
				
				
				outputNames = ["pre$nmis","imp"];					
				
				//Query is created from runScript with same signature from Jave side
				var showIntermediateResults:Boolean = intermediateResultCB.selected;
				var showWarnings:Boolean = warningCB.selected;
				var script:String = "library(norm) \n pre<-prelim.norm(Bind) \n Em <- em.norm(pre) \n rngseed(34215) \n " +
									"Da <- da.norm(pre, Em, steps = 20) \n imp <- imp.norm(pre, Da, Bind)";
				
				var query:AsyncToken = Rservice.handlingMissingData(assignNames, assignToBeValues, outputNames, script,"", showIntermediateResults,showWarnings);
				DelayedAsyncResponder.addResponder(query, handleRunScriptResult, handleRunScriptFault, joinedColumnQKeys);
				
			}
			
			/* protected function loadIntoReditor(xml:XML):void{
				assignTA.text = xml.assignNames;
				outputTA.text = xml.outputScript;
			}
			
			private var focusedTA:TextArea = null; */
			private var outputNames:Array = new Array();//global
			
			
		
		]]>
	</mx:Script>
	
</DraggablePanel>
