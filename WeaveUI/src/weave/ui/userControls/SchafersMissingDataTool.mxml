<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<!--
SchafersMissingDataImputation

1. Pick your columns
2. Assign variable names to those columns
3. Input an R script using those variable names
4. List the outputs you want
5. The columns get joined on the client-side using the keys (record identifiers) to produce flat Arrays lined up by row index
6. These columns become the input to the R script on the server, the server runs the script and returns the results.
7. On the client side, any returned Arrays are matched up with the original keys using the same row order to become columns.
8. Any other results are just printed out to the text area.

@spurushe

-->
<DraggablePanel xmlns="weave.ui.*" xmlns:mx="http://www.adobe.com/2006/mxml" 
				horizontalScrollPolicy="off" verticalScrollPolicy="off"
				title="Schafers Missing Data Imputation"
				x="15%" width="70%" y="15%" height="70%"
				backgroundColor="#EFF4BC" 
				layout="horizontal"
				autoLayout="true"
				>
	<mx:HBox width="100%" height="100%" paddingLeft="{padding}" paddingRight="{padding}" paddingTop="{padding}" paddingBottom="{padding}">
		<mx:VBox width="20%" height="100%" verticalGap="0">
			<mx:Label text="(1) Select data to use in your script"/>
			<ColumnListComponent id="inputColumnList" label="Input columns" hashMap="{variables}" width="100%" height="100%"   />			
		</mx:VBox>
		<mx:VBox  id="vb" width="45%" height="100%" verticalGap="0">
			<LabelWithWordWrap text="(2)Assign variable names and check Attributes for Missing Data"/>
			<mx:TextArea id = "assignTA" width="100%" height="100%" wordWrap="false"/>
			<mx:Spacer height="{padding}"/>
			
			<mx:Spacer height="{padding}"/>
			<mx:Button id="checkforNA" label="Check for Missing Data" buttonDown="checkForNA_buttonDownHandler(event)"/>
			<mx:CheckBox id="checkForNaCheckbox" label= "Check missing record number?" click="checkForNaCheckbox_clickHandler(event)"/>
			<mx:CheckBox id="checkPatternCheckbox" label= "Check missing data pattern?" click="checkForNaCheckbox_clickHandler(event)"/>
			<mx:Spacer height="{padding}"/>
			
			
			<LabelWithWordWrap text="(5) Specify script outputs to display, separated by commas"/>
			<mx:TextArea id = "outputTA" width="100%" height="100%" wordWrap="false"/>
			
			<mx:Spacer height="{padding}"/>
			
			<LabelWithWordWrap text="(6) Run your script on the server"/>
			<mx:HBox>
				<!--mx:Button id="B2" label="Run script"  buttonDown="viewAndSendbuttonClickHandler()"/-->
				<mx:CheckBox id="intermediateResultCB" label="Verbose" toolTip="Show intermediate results from R"/>
				<mx:CheckBox id="warningCB" label="Warnings" toolTip="Show warnings from R"/>
			</mx:HBox>
			
			<mx:Spacer height="{padding}"/>
			
			
								
		</mx:VBox>
		<mx:VBox width="25%" height="100%" verticalGap="0">
			<mx:Label text="Result"/>
			<mx:DataGrid id="ResultColumns"   width= "100%" height="100%"/>
			
		</mx:VBox>
	</mx:HBox>
	
	<mx:Script>
		<![CDATA[
			import mx.charts.chartClasses.DataDescription;
			import mx.collections.ArrayCollection;
			import mx.controls.DataGrid;
			import mx.controls.Image;
			import mx.controls.dataGridClasses.DataGridColumn;
			import mx.events.FlexEvent;
			import mx.rpc.AsyncToken;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.utils.ObjectUtil;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.linkBindableProperty;
			import weave.api.newDisposableChild;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableString;
			import weave.core.weave_internal;
			import weave.data.AttributeColumns.CSVColumn;
			import weave.data.AttributeColumns.StringColumn;
			import weave.data.KeySets.KeySet;
			import weave.services.DelayedAsyncResponder;
			import weave.services.WeaveStatisticsServlet;
			import weave.services.beans.RResult;
			import weave.utils.ColumnUtils;
			import weave.utils.ResultUtils;
			import weave.utils.VectorUtils;
			import weave.visualization.tools.SimpleVisTool;
			
			private const padding:int = 5;
			
			private static function get selection():KeySet
			{
				return Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			}
			
			public const variables:LinkableHashMap = registerLinkableChild(this, new LinkableHashMap(IAttributeColumn));
			private var Rservice:WeaveStatisticsServlet = new WeaveStatisticsServlet(Weave.properties.rServiceURL.value);
			public const inputTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			public const plotTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			public const outputTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			public const assignTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			
			
			override protected function constructor():void
			{
				super.constructor();				
				var columns:Array = SimpleVisTool.getDefaultColumnsOfMostCommonKeyType();
				for (var i:int = 0; i < columns.length; i++)
					variables.requestObjectCopy(null, columns[i]);
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				//RimageBtn.enabled = false;
				//linkBindableProperty(inputTALinkable,inputTA,"text");
				//linkBindableProperty(plotTALinkable,plotTA,"text");
				linkBindableProperty(outputTALinkable,outputTA,"text");
				linkBindableProperty(assignTALinkable,assignTA,"text");
			}
			
			/**
			 * @return A multi-dimensional Array like [keys, [data1, data2, ...]] where keys implement IQualifiedKey
			 */
			private function joinColumns(columns:Array):Array
			{
				var keys:Array = selection.keys.length > 0 ? selection.keys : null;
				//make dataype Null, so that columns will be sent as exact dataype to R
				//if mentioned as String or NUmber ,will convert all columns to String or Number .
				var result:Array = ColumnUtils.joinColumns(columns,null, true, keys);
				return [result.shift(), result];
			}
			
			/*private function viewAndSendbuttonClickHandler(): void{
				var result:Array = new Array();
				//Columns from Joined columns Method
				var joinedColumnQKeys:Array;
				var joinedColumnKeys:Array;
				var joinedColumns:Array;
				//Columns from ColumnListComponent 
				var selectedColumns:Array = variables.getObjects();
				
				var attributeColumns:Array = new Array();
				//Use as Attribute column as joinColumns takes mebers of IAttributeColumn
				for(var i:int = 0; i<selectedColumns.length; i++)
				{
					attributeColumns[i] = selectedColumns[i] as IAttributeColumn;
				}
				//joinColumns Called only When columns are added to ColumnListComponent
				//if(selectedColumns.length == 0)
				//	return;
				if(selectedColumns.length >0)
				{					
					// get records for keys common to all columns 
					result = joinColumns(attributeColumns);
					joinedColumnQKeys = result[0];
					joinedColumns = result[1];
					//this is for JRI service
					//joinedColumnKeys = joinedColumnQKeys.concat();
				}
				
			
				//Values need to assign for Column names in R
				var assignValues:Array = joinedColumns;
				//Names for Column that need to be used in R
				var RscriptAssignNames:String = assignTA.text;
				var assignNames:Array = VectorUtils.flatten(WeaveAPI.CSVParser.parseCSV(assignTA.text));
				//Script for R input
								
				//Script to get output from R
				var outputNames:Array = VectorUtils.flatten(WeaveAPI.CSVParser.parseCSV(outputTA.text));
				
				//Query is created from runScript with same signature from Jave side
				var showIntermediateResults:Boolean = intermediateResultCB.selected;
				var showWarnings:Boolean = warningCB.selected;
				var script:String = "d<- cbind(x,y) \n library(norm) \n r<-prelim.norm(d)";
				var query:AsyncToken = Rservice.runScript(assignNames, assignValues, outputNames, script,"", showIntermediateResults,showWarnings);
				
				DelayedAsyncResponder.addResponder(query, handleRunScriptResult, handleRunScriptFault, joinedColumnQKeys);
			}*/
			
			
			
			[Bindable]
			private var finalCollection:ArrayCollection = new ArrayCollection();
			private var headings:Array = new Array();
			private var currentDataGrid:DataGrid = null;
			private function handleRunScriptResult(event:ResultEvent, token:Object = null):void
			{
				//Object to stored returned result - Which is array of object{name: , value: }
				var Robj:Array = event.result as Array;
				//trace('Robj:',ObjectUtil.toString(Robj));
				if (Robj == null)
				{
					reportError("R Servlet did not return an Array of results as expected.");
					return;
				}
				
				//Clears previous Result
				//ResultTA.text = "";
				//trace(ObjectUtil.toString(event.result));
				
				//Collecting all RResult Objects into an Array 
				var RresultArray:Array = new Array();
				//collecting Objects of type RResult(Should Match result object from Java side)
				for (var i:int = 0; i < (event.result).length; i++)
				{
					if (Robj[i] == null)
					{
						trace("WARNING! R Service returned null in results array at index "+i);
						continue;
					}
					var rResult:RResult = new RResult(Robj[i]);
					RresultArray.push(rResult);				
				}
				
				
				finalCollection = fillingMissingDataNumber(headings, RresultArray[0].value);
				
				
				//Displaying the Number of Missing records in each Column
				if(currentDataGrid)
				{
					vb.removeChild(currentDataGrid);					
				}
				var missingDataGrid:DataGrid = new DataGrid();
				missingDataGrid.rowCount = 1;
				missingDataGrid.width = vb.width;
				missingDataGrid.dataProvider = finalCollection;
				missingDataGrid.verticalScrollPolicy = "off";
				vb.addChildAt(missingDataGrid, 3);
				currentDataGrid = missingDataGrid;
				
				
				
				//TO display in ResultTA
			/*	var resultString:String = "";
				for (var j:int = 0; j < RresultArray.length; j++)
				{								
					resultString = resultString + RresultArray[j].name + ":\n" + ObjectUtil.toString(RresultArray[j].value) +"\n";
				}
				while (resultString.search("\"") > 0)
				{
					resultString = resultString.replace("\"","");
				}*/
				
				//To make availabe for Weave -Mapping with key returned from Token
				var keys:Array = token as Array;
				
				//Objects "(object{name: , value:}" are mapped whose value length that equals Keys length
				for (var p:int = 0;p < RresultArray.length; p++)
				{
					if(RresultArray[p].name == "Plot Results")
					{
						var imagePanel:DraggablePanel = Weave.root.requestObject(null, DraggablePanel, false);
						var image:Image = new Image();
						image.source = RresultArray[p].value;
						imagePanel.addChild(image);
						imagePanel.panelWidth.value = "500";
						imagePanel.panelHeight.value = "500";
					}
					if(RresultArray[p].value is Array){
						if(keys){
							if ((RresultArray[p].value).length == keys.length){
								if (RresultArray[p].value[0] is String)	{
									var testStringColumn:StringColumn = Weave.root.requestObject(RresultArray[p].name, StringColumn, false);
									var keyVec:Vector.<IQualifiedKey> = new Vector.<IQualifiedKey>();
									var dataVec:Vector.<String> = new Vector.<String>();
									VectorUtils.copy(keys, keyVec);
									VectorUtils.copy(Robj[p].value, dataVec);
									testStringColumn.setRecords(keyVec, dataVec);
									if (keys.length > 0)
										testStringColumn.weave_internal::metadata.@keyType = (keys[0] as IQualifiedKey).keyType;
									testStringColumn.weave_internal::metadata.@name = RresultArray[p].name;
								}
								else{
									var table:Array = [];
									for (var k:int = 0; k < keys.length; k++)
										table.push([ (keys[k] as IQualifiedKey).localName, Robj[p].value[k] ]);
									
									//testColumn are named after respective Objects Name (i.e) object{name: , value:}
									var testColumn:CSVColumn = Weave.root.requestObject(RresultArray[p].name, CSVColumn, false);
									testColumn.keyType.value = keys.length > 0 ? (keys[0] as IQualifiedKey).keyType : null;
									testColumn.numericMode.value = true;
									testColumn.csvData.value = WeaveAPI.CSVParser.createCSVFromArrays(table);
									testColumn.title.value = RresultArray[p].name;
								}
							}
						}						
					}										
				}
			}
			
			private function handleRunScriptFault(event:FaultEvent, token:Object = null):void
			{
				trace(["fault", token, event.message].join('\n'));
				reportError(event);
			}
			
			
			private function fillingMissingDataNumber(headings:Array, values:Array):ArrayCollection
			{
				
					var eachColumn:Object = new Object();
					
					for( var k:int = 0; k < values.length; k++)
					{
						eachColumn[headings[k]] = values[k];
					}
					finalCollection.addItem(eachColumn);
			
				return finalCollection;
			}

			
			protected function assignTA_clickHandler(event:MouseEvent):void
			{
				var selectedTA:TextArea = (focusManager.getFocus()) as TextArea;
				focusedTA = selectedTA;
			} 
			
			[Bindable]
			private var assignToBeValues:Array = new Array();
			protected function checkForNA_buttonDownHandler(event:FlexEvent):void
			{
				var result:Array = new Array();
				//Columns from Joined columns Method
				var joinedColumnQKeys:Array;
				var joinedColumns:Array;
				//Columns from ColumnListComponent 
				var selectedColumns:Array = variables.getObjects();
				
				var attributeColumns:Array = new Array();
				//Use as Attribute column as joinColumns takes members of IAttributeColumn
				for(var i:int = 0; i<selectedColumns.length; i++)
				{
					attributeColumns[i] = selectedColumns[i] as IAttributeColumn;
				}
				//joinColumns Called only When columns are added to ColumnListComponent
				
				if(selectedColumns.length >0)
				{					
					// get records for keys common to all columns 
					result = joinColumns(attributeColumns);
					joinedColumnQKeys = result[0];
					joinedColumns = result[1];
					
				}
				
				
				var ar:ArrayCollection = ResultUtils.resultAsArrayCollection(joinedColumns);
				 assignToBeValues = joinedColumns;
				 ResultColumns.dataProvider = ar;
				 trace(assignToBeValues[0]);
				 var displayColumns: Array = new Array();
				 
				/*  for (var f:int = 0; f < assignToBeValues.length; f++)
				 {
					 for(var f1:int = 0; f1 < assignToBeValues[f].
				 } */
				//variable names for the columns to be used in R
				var RscriptAssignNames:String = assignTA.text;//as complete string
				
				//broken into individual variable names
				var assignNames:Array = VectorUtils.flatten(WeaveAPI.CSVParser.parseCSV(assignTA.text));
				
				//to get the headings for the missing data columns
				headings = assignNames;
				
				//Script to get output from R
				//var outputNames:Array = VectorUtils.flatten(WeaveAPI.CSVParser.parseCSV(outputTA.text));
				
				//Query is created from runScript with same signature from Jave side
				var showIntermediateResults:Boolean = intermediateResultCB.selected;
				var showWarnings:Boolean = warningCB.selected;
				var script:String = "d<- cbind(x,y) \n library(norm) \n r<-prelim.norm(d)";
				var query:AsyncToken = Rservice.runScript(assignNames, assignToBeValues, outputNames, script,"", showIntermediateResults,showWarnings);
				
				DelayedAsyncResponder.addResponder(query, handleRunScriptResult, handleRunScriptFault, joinedColumnQKeys);
			}
			
			protected function loadIntoReditor(xml:XML):void{
				assignTA.text = xml.assignNames;
				outputTA.text = xml.outputScript;
			}
			
			private var focusedTA:TextArea = null;
			private var outputNames:Array = new Array();//global
			
			
			
			protected function checkForNaCheckbox_clickHandler(event:MouseEvent):void
			{
				var o:int = 0;
				if(checkForNaCheckbox.selected)
				{
					outputNames = VectorUtils.flatten(WeaveAPI.CSVParser.parseCSV("r$nmis"));
					o++;
				}
				
				if (checkPatternCheckbox.selected)
				{
					outputNames = VectorUtils.flatten(WeaveAPI.CSVParser.parseCSV("r$r"));
					o++;
				}
				
			}
			
		]]>
	</mx:Script>
	
</DraggablePanel>
