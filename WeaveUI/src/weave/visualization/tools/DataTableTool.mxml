<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<!---
@author skolman
@author kmonico
@author sanbalag
-->
<ui:DraggablePanel xmlns="weave.visualization.tools.*"
				   xmlns:mx="http://www.adobe.com/2006/mxml"
				   xmlns:ui="weave.ui.*" 
				   xmlns:CustomDataGrid="weave.ui.CustomDataGrid.*"
				   layout="absolute"
				   title="Data Table" xmlns:editors="weave.editors.*"
				   >
	<mx:VBox width="100%" height="100%" id="tableArea" verticalGap="0" horizontalScrollPolicy="off">
		<mx:HBox id="topControls" horizontalAlign="left" width="100%">
			<mx:Label text="Key type:"/>
			<ui:CustomComboBox id="keyTypeCombo" change="keyTypeChangeEventHandler()" toolTip="Only columns of the selected key type will be shown."/>
			<mx:Button label="Edit columns..." click="AttributeSelectorPanel.openDefaultSelector(columns)"/>
		</mx:HBox>
		<mx:HBox minWidth="0" horizontalGap="0" borderStyle="solid"  id="filterControls" width="100%"  verticalAlign="middle" horizontalScrollPolicy="off"/>
		<CustomDataGrid:CustomDataGrid id="dataGrid" 
									   scroll="handleDataGridScroll()"
									   horizontalScrollPolicy="auto"
									   verticalScrollPolicy="auto"
									   dataProvider="{dataRowKeys}" 
									   width="100%" height="100%"
									   allowMultipleSelection="true"
									   minWidth="0"
									   copy="handleDataCopy(event)" 
									   change="handleItemSelection(event)"
									   doubleClick="handleItemSelection(event)" doubleClickEnabled="true" 
									   headerShift="handleColumnReorder(event)"
									   headerRelease="handleHeaderRelease(event)"
									   paddingBottom="0" paddingTop="0" paddingLeft="0" paddingRight="0"									   
									   fontWeight="normal"
									   alternatingItemColors="{[0xffffff, 0xEEF6FF]}"
									   rollOverColor="0xDADAFF"
									   selectionColor="0xFFAAAA"
									   />
		
		<mx:HBox id="bottomControls" width="100%" paddingTop="3" paddingLeft="3" paddingBottom="3" paddingRight="3">
			<mx:Button label="Export Data..." click="exportCSV()" />
			<mx:Button click="moveSelectedToTop()" label="Move Selected Items to top"/>
		</mx:HBox>
	</mx:VBox>
	
	<mx:Number id="columnWidthScale">1</mx:Number>
	
	<mx:Script>
		<![CDATA[
			import flash.desktop.Clipboard;
			import flash.desktop.ClipboardFormats;
			
			import mx.collections.ArrayCollection;
			import mx.collections.ICollectionView;
			import mx.controls.dataGridClasses.DataGridColumn;
			import mx.core.mx_internal;
			import mx.events.DataGridEvent;
			import mx.events.IndexChangedEvent;
			import mx.events.ResizeEvent;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.copySessionState;
			import weave.api.core.ILinkableObject;
			import weave.api.data.DataTypes;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IColumnWrapper;
			import weave.api.data.IPrimitiveColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.detectLinkableObjectChange;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.data.AttributeColumns.DynamicColumn;
			import weave.data.AttributeColumns.ImageColumn;
			import weave.data.AttributeColumns.KeyColumn;
			import weave.data.AttributeColumns.SecondaryKeyNumColumn;
			import weave.data.KeySets.KeyFilter;
			import weave.data.KeySets.KeySet;
			import weave.ui.AttributeSelectorPanel;
			import weave.ui.CustomDataGrid.DataGridCellRenderer;
			import weave.ui.CustomDataGrid.IFilterComponent;
			import weave.ui.CustomDataGrid.SearchFilterComponent;
			import weave.ui.CustomDataGrid.SliderFilterComponent;
			import weave.ui.CustomDataGrid.WeaveCustomDataGridColumn;
			import weave.ui.DraggablePanel;
			import weave.utils.ColumnUtils;
			import weave.utils.EventUtils;
			import weave.utils.LinkableTextFormat;
			import weave.utils.NumberUtils;
			import weave.utils.ProbeTextUtils;
			use namespace mx_internal;
			
			public const columns:LinkableHashMap = registerLinkableChild(this, new LinkableHashMap(IAttributeColumn));
			public const columnWidths:LinkableHashMap = registerLinkableChild(this, new LinkableHashMap(LinkableString));
			public const filterComponents:LinkableHashMap = registerLinkableChild(this,new LinkableHashMap(IFilterComponent));	
			private const dataGridColumns:Dictionary = new Dictionary();
			private var _currentDataGridColumns:Array = [];
			
			
			private var dataTableKeySet:KeySet = new KeySet();
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			private var _selection:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			
			public const sortFieldIndex:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0));
			public const sortInDescendingOrder:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false));
			
			override protected function constructor():void
			{
				super.constructor();
				
				var probeHeaderColumns:Array = ProbeTextUtils.probeHeaderColumns.getObjects(IAttributeColumn);
				var probedColumns:Array = ProbeTextUtils.probedColumns.getObjects(IAttributeColumn);
				var allColumns:Array = (probeHeaderColumns.concat as Function).apply(null, probedColumns);
				for (var i:int = 0; i < allColumns.length; i++)
				{
					var dynamicColumn:DynamicColumn = columns.requestObject(null, DynamicColumn, false);
					var probedColumn:ILinkableObject = allColumns[i] as ILinkableObject;
					if (probedColumn is DynamicColumn)
						copySessionState(probedColumn, dynamicColumn);
					else
						dynamicColumn.requestLocalObjectCopy(probedColumn);
				}
				
				
				getCallbackCollection(this).addImmediateCallback(this, invalidateDisplayList);
				_selection.addImmediateCallback(this,invalidateDisplayList);
				getCallbackCollection(LinkableTextFormat.defaultTextFormat).addImmediateCallback(this,invalidateDisplayList);				
			}
			
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
				linkBindableProperty(showControls, showControlsCheckBox, "selected");
				linkBindableProperty(showFilters, showFiltersCheckBox, "selected");
				linkBindableProperty(showColors,showColorsCheckBox,"selected");
				linkBindableProperty(removeHorizontalScrollBar,removeHScrollBarCheckBox,"selected");
				
				columns.childListCallbacks.addImmediateCallback(this, handleColumnListChange,null,true);
				columnWidths.childListCallbacks.addImmediateCallback(this,updateColumnWidths,null,true);
				
				dataRowKeys.filterFunction = filterKeys;
				dataRowKeys.refresh();
				handleGlobalSelectionChange();
				dimensionsList.hashMap = columns;
								
				EventUtils.addEventCallback(dataGrid,DataGridEvent.COLUMN_STRETCH,handleColumnStretch);
				EventUtils.addEventCallback(dataGrid,ResizeEvent.RESIZE,updateColumnWidths);
				
				UIUtils.linkDisplayObjects(filterControls,filterComponents);
				// temporary solution
				var handleColorColumnChange:Function = function():void{
					(dataGrid.dataProvider as ICollectionView).refresh();
				};
				getCallbackCollection(Weave.root.getObject(Weave.DEFAULT_COLOR_COLUMN)).addGroupedCallback(this, handleColorColumnChange);
			}
			
			//we need to do this to set the arrow to the correct column
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.updateDisplayList(unscaledWidth,unscaledHeight);
				
				if (detectLinkableObjectChange(updateDisplayList, columns)){
					forceSortCallback();
					handleColumnsChange();										
				} 				
				if (detectLinkableObjectChange(updateDisplayList, filterComponents)){					
					dataGrid.invalidateFilters();
				}
				if (detectLinkableObjectChange(updateDisplayList, dataTableKeySet)){
					updateDataRowKeys();
				}
				if (detectLinkableObjectChange(updateDisplayList, _subset)){
					handleSubsetChange();		
				}
				if (detectLinkableObjectChange(updateDisplayList, _selection)){
					handleGlobalSelectionChange();
				}
				if (detectLinkableObjectChange(updateDisplayList, LinkableTextFormat.defaultTextFormat)){
					handleFontChange();
				} 
				if(detectLinkableObjectChange(updateDisplayList , sortFieldIndex)){
					sortCallback();
				}
				if(detectLinkableObjectChange(updateDisplayList , sortInDescendingOrder)){
					sortCallback();
				}
			}
			
			override protected function handlePanelTitleChange():void
			{
				super.handlePanelTitleChange();
				if (!panelTitle.value)
					title = "Data Table";
			}
			
			private function handleFontChange():void
			{
				if (!dataGrid)
					return callLater(handleFontChange);				
				LinkableTextFormat.defaultTextFormat.copyToStyle(dataGrid);
			}
			
			private function handleSubsetChange():void{
				showFilters.value = false;
				dataRowKeys.refresh();	
			}
			
			public const exportKeys:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true));
			
			public const showControls:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), updateControls);
			private function updateControls():void
			{
				if (!parent)
					return callLater(updateControls);
				try
				{
					if (showControls.value)
					{
						if (!topControls.parent)
							tableArea.addChildAt(topControls, 0);
						if (!bottomControls.parent)
							tableArea.addChild(bottomControls);
					}
					else
					{
						if (topControls.parent)
							tableArea.removeChild(topControls);
						if (bottomControls.parent)
							tableArea.removeChild(bottomControls);
					}
				}
				catch (e:Error) 
				{
				}
			}
			private var toolDataGridWidthDiff:Number=0;
			public const removeHorizontalScrollBar:LinkableBoolean = registerLinkableChild(this,new LinkableBoolean(false),updateColumnWidths);
			
			public const showFilters:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false),updateFilters);
			private function updateFilters():void
			{
				if (!parent)
					return callLater(updateFilters);
				try
				{
					if (showFilters.value){
						if (!filterControls.parent){							
							// if there are controls above where the filters should be.. add the filters at index 1, otherwise use index 0
							tableArea.addChildAt(filterControls, topControls.parent ? 1 : 0);
							dataGrid.enableFilters = true;
						}
					}
					else{						
						if (filterControls.parent){							
							tableArea.removeChild(filterControls);
							dataGrid.enableFilters = false;
						}	
					}
				}
				catch (e:Error) 
				{
				}
			}
			
			
			private const dataRowKeys:ArrayCollection = new ArrayCollection([]);	
			
			public const showColors:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), updateColumnCellDisplay);
			private function updateColumnCellDisplay():void{
				var colNames:Array = columns.getNames();
				var i:int;
				var filterableColumn:WeaveCustomDataGridColumn;
				if(showColors.value){
					for(i = 0; i<colNames.length;i++){
						filterableColumn = _currentDataGridColumns[i] as WeaveCustomDataGridColumn;
						var cf:ClassFactory = new ClassFactory(DataGridCellRenderer);
						cf.properties = {colorColumn: Weave.root.getObject(Weave.DEFAULT_COLOR_COLUMN),keySet: Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet};
						filterableColumn.itemRenderer = cf;
					}
				}
				else{
					for(i = 0; i<colNames.length;i++){
						filterableColumn = _currentDataGridColumns[i] as WeaveCustomDataGridColumn;	
						//while loading initially - WeaveCustomDataGridColumn wont get created
						if(filterableColumn){
							filterableColumn.itemRenderer =  new ClassFactory(Label);	
						}						
					}
				}
			}
			
			private function addImageColumn():void
			{
				var imageColumnName:String = dimensionsList.hashMap.generateUniqueName("ImageColumn");
				var imageCol:ImageColumn = dimensionsList.hashMap.requestObject(imageColumnName,ImageColumn, false);				
				AttributeSelectorPanel.openDefaultSelector(imageCol);
			}
			
			private var fr:FileReference = new FileReference();	// CSV download file reference
			private function exportCSV():void
			{
				try
				{
					fr.save(generateCSV(), "Weave Data Export.csv");
				}
				catch (e:Error)
				{
					reportError(e);
				}
			}
						
			private var headerClicked:Boolean = false;
			private function handleHeaderRelease(event:DataGridEvent=null):void
			{
				if (event!=null)
				{
					var c:DataGridColumn = dataGrid.columns[event.columnIndex];
					// we do a callLater to get the correct sorting order. 
					// There is a bug in flex because of which the c.sortDescending will always return false
					callLater(getOrder,[c,event.columnIndex]);
				}
			}
			
			private function getOrder(column:DataGridColumn,index:int):void
			{
				sortInDescendingOrder.value = column.sortDescending;
				sortFieldIndex.value = index;
			}
			
			private function forceSortCallback():void{ 
				sortCallback(true); 
			}
			
			private function sortCallback(forced:Boolean = false):void
			{
				if(isNaN(sortFieldIndex.value))
					return;
				
				var c:DataGridColumn = dataGrid.columns[sortFieldIndex.value];
				if(c == null)
					return;
				
				// sort by the column specified in the session state , flip the sorting order if it is wrong
				if (forced || dataGrid.sortIndex != sortFieldIndex.value || c.sortDescending != sortInDescendingOrder.value)
				{
					dataGrid.dispatchEvent(new DataGridEvent(DataGridEvent.HEADER_RELEASE, false, true, sortFieldIndex.value, null, 0, null, null, 0));
				}				
			}
			
			
			private function handleItemSelection(event:Event=null):void
			{
				dataGrid.validateNow();				
				var selectedKeys:Array = new Array();
				for (var i:int = 0; i < dataGrid.selectedIndices.length; i++)
				{
					selectedKeys[i] = (dataGrid.dataProvider as ArrayCollection).getItemAt( dataGrid.selectedIndices[i] ) as IQualifiedKey;
				}
				_selection.replaceKeys(selectedKeys);
			}
			
			
			
			
			private function handleGlobalSelectionChange(e:Event = null):void
			{
				if (!parent)
					return callLater(handleGlobalSelectionChange);
				
				var selectedItems:Array = [];
				for each (var item:Object in dataGrid.dataProvider)
				{
					if (_selection.containsKey(item as IQualifiedKey))
						selectedItems.push(item);
				}	
				dataGrid.selectedItems = selectedItems;
				
			}
			
			
			private function filterKeys(item:Object):Boolean
			{
				if(_subset.containsKey(item as IQualifiedKey))
					return true;
				else 
					return false;
			}
			
			
			
			
			private function moveSelectedToTop():void
			{
				//push selected Objects into an Array
				var selectedItems:Array = dataGrid.selectedItems;
				
				//datagrid.selectedItems returns null. So have to loop through indices to get the items
				(dataGrid.dataProvider as ArrayCollection).sort = null;				
				
				for each(var item:Object in selectedItems)
				{
					var index:int = dataRowKeys.getItemIndex(item);
					dataRowKeys.removeItemAt(index);
					dataRowKeys.source.unshift(item);
				}
				
				dataRowKeys.refresh();
				dataGrid.validateNow();
				handleGlobalSelectionChange();
				dataGrid.scrollToIndex(0);
			}
			
			
			
			private function handleKeyTypeChange():void
			{
				for each (var col:WeaveCustomDataGridColumn in dataGrid.columns)
				{
					if(keyTypeCombo.selectedItem == "Show All" || (col.attrColumn is KeyColumn) || (ColumnUtils.getKeyType(col.attrColumn) == keyTypeCombo.selectedItem))
						col.visible = true;
					else 
						col.visible = false;
				}				
				updateKeys();
				updateDataRowKeys();
				
			}
			
			private function keyTypeChangeEventHandler():void
			{
				filterByKeyType.value = keyTypeCombo.selectedItem as String;
				handleKeyTypeChange();
			}
			
			public const filterByKeyType:LinkableString = newLinkableChild(this,LinkableString,updateKeyTypeComboBox,true);
			private function updateKeyTypeComboBox():void
			{
				if (keyTypeCombo == null)
					return callLater(updateKeyTypeComboBox);
				
				var prevIndex:int = keyTypeCombo.selectedIndex;
				var keyTypeList:Array = new Array();
				keyTypeList.push("Show All");
				for each (var attrCol:IAttributeColumn in columns.getObjects())
				{
					if(attrCol is KeyColumn)
						continue;
					
					var keyType:String = ColumnUtils.getKeyType(attrCol);
					
					if(keyType == null)
						keyType = "null"
					if(keyTypeList.indexOf(keyType) == -1)
						keyTypeList.push(keyType);
				}
				keyTypeCombo.dataProvider = keyTypeList;				
				keyTypeCombo.selectedItem = filterByKeyType.value || 'Show All';
			}
			
			public function getExportDataProvider():*
			{
				for each (var column:IAttributeColumn in columns.getObjects())
				{
					while (!(column is IPrimitiveColumn) && column is IColumnWrapper)
						column = (column as IColumnWrapper).internalColumn;
					
					if (column is SecondaryKeyNumColumn)
					{
						// dimension slider hack -- relies on previously set SecondaryKeyNumColumn.allKeysHack = true;
						var key:IQualifiedKey;
						var keyLookup:Dictionary = new Dictionary(true);
						for each (column in columns.getObjects())
						for each (key in column.keys)
						keyLookup[key] = true;
						var keys:Array = [];
						for (var keyObj:* in keyLookup)
							keys.push(keyObj);
						return keys;
					}
				}
				return dataGrid.dataProvider;
			}
			private function generateCSV():String{
				var keys:* = getExportDataProvider();
				// each record has a property named after the column title equal to the value in that column for the current key
				var dataType:Class = (keys === dataGrid.dataProvider) ? null : String; // dimension slider hack
				var dataTableColumns:Array = columns.getObjects();
				var generatedCSVstring:String = ColumnUtils.generateTableCSV(dataTableColumns,keys,dataType);
				return generatedCSVstring;
			}
			
			private function handleDataCopy(event:Event):void
			{											
				Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT,generateCSV() );
			}
			
			
			private var _minSuggestedColumnSize:int = 100;
			
			private function updateDataRowKeys():void
			{
				dataRowKeys.source = dataTableKeySet.keys;
			}	
			
			private function updateKeys():void
			{
				dataTableKeySet.clearKeys();
				for each (var column:IAttributeColumn in columns.getObjects())
				{	
					if(keyTypeCombo.enabled)
					{
						if(keyTypeCombo.selectedItem == "Show All" || ColumnUtils.getKeyType(column) == keyTypeCombo.selectedItem)
							dataTableKeySet.addKeys(column.keys);
					}
					else
						dataTableKeySet.addKeys(column.keys);
				}
			}
			
			
			private function handleColumnsChange():void
			{
				updateKeyTypeComboBox();
				updateDataGridColumns();
				handleKeyTypeChange();
				handleGlobalSelectionChange();
				//DraggablePanel method
				updateBorders();				
				updateColumnCellDisplay();				
			}
			
			private function updateDataGridColumns():void
			{
				// if there isn't a parent or the grid isn't fully instantiated, return
				if (!parent || dataGrid.width == 0)
					return callLater(updateDataGridColumns);
				try {
					 var attrColumns:Array = columns.getObjects();
					var totalWidth:Number = dataGrid.width - dataGrid.getScrollWidth(CustomDataGrid.VERTICAL_SCROLL);
					_currentDataGridColumns = [];
					for each (var attrColumn:IAttributeColumn in attrColumns)
					{
						var columnName:String = columns.getName(attrColumn);						
						var dataType:String = ColumnUtils.getDataType(attrColumn);
						
						//column Section
						var dgc:WeaveCustomDataGridColumn;
						if(dataGridColumns[columnName]){
							dgc = dataGridColumns[columnName];
						}
						else{
							dgc = new WeaveCustomDataGridColumn(attrColumn);	
							dataGridColumns[columnName] = dgc;
						}
											
						_currentDataGridColumns.push(dgc);
						
						//filterComponent Section
						var classDef:Class = null;
						if (attrColumn is KeyColumn){
							classDef = SearchFilterComponent;										
						}
						if (dataType == DataTypes.STRING){
							classDef = SearchFilterComponent;
						}
						else if(dataType == DataTypes.NUMBER){
							classDef = SliderFilterComponent;
						}						
						dgc.filterComponent = filterComponents.requestObject(columnName, classDef, false);
										
						//columnWidth section
						var sessionedWidth:LinkableString = columnWidths.requestObject(columnName, LinkableString,false);
												
					}  
					dataGrid.columns = _currentDataGridColumns;
				}
				catch (error:Error)	{
					reportError(error);
				}
			}
						
			private function handleColumnReorder(event:IndexChangedEvent):void
			{
				var newColumnOrder:Array = [];				
				for(var i:int = 0; i< dataGrid.columns.length; i++)
				{
					var currDGcolumn:WeaveCustomDataGridColumn = dataGrid.columns[i] as WeaveCustomDataGridColumn;
					var columnName:String = columns.getName(currDGcolumn.attrColumn as ILinkableObject);
					newColumnOrder.push(columnName);
				}			
				columns.setNameOrder(newColumnOrder);				
			}
			
			private function handleColumnListChange():void
			{			
				showKeyColumnCheckBox.selected = columns.getNames(KeyColumn).length > 0;				
				
				//if column is added , we need to add respective sessioned FilterComponent and ColumnWidth
				if (columns.childListCallbacks.lastObjectAdded){
					
				}  			
				//if column is removed , we need to remove respective sessioned FilterComponent and ColumnWidth
				else if (columns.childListCallbacks.lastObjectRemoved){						
					filterComponents.removeObject(columns.childListCallbacks.lastNameRemoved);					
					delete dataGridColumns[columns.childListCallbacks.lastNameRemoved]
					columnWidths.removeObject(columns.childListCallbacks.lastNameRemoved);
				}
				else{
					filterComponents.setNameOrder(columns.getNames());
					columnWidths.setNameOrder(columns.getNames());
				}
			}
			
			private function handleColumnStretch():void
			{
				// go through each column and set the sessioned widths
				var i:int;
				var totalWidth:Number = dataGrid.width - dataGrid.getScrollWidth(CustomDataGrid.VERTICAL_SCROLL);
				for (i = 0; i < _currentDataGridColumns.length; ++i)
				{
					var dgc:WeaveCustomDataGridColumn = _currentDataGridColumns[i];
					var column:IAttributeColumn = dgc.attrColumn;
					var columnName:String = columns.getName(column);
					var sessionedWidth:LinkableString = columnWidths.getObject(columnName) as LinkableString;
					var width:Number = dgc.width;
					if (isNaN(width) || width <= 5) // this happens when a column is stretched all the way to the right
						width = _minSuggestedColumnSize;					
					sessionedWidth.value = (100 * width / totalWidth) + "%";
					if(dgc.filterComponent){
						dgc.filterComponent.width = dgc.width;
					}					
				}
			}
			
		
			
			public  function updateColumnWidths():void
			{				
				// if there isn't a parent or the grid isn't fully instantiated, return
				if (!parent || dataGrid.width == 0  )
				{
					callLater(updateColumnWidths);
					return;
				}				
				var columnCount:Number = columns.getObjects().length;
				//handleColumnWidthChildListChange get called only one time
				if (_currentDataGridColumns.length   < columnCount  )	{
					return;
				}  
				
				var dataGridColumnsWidth:Number = dataGrid.width - dataGrid.getScrollWidth(CustomDataGrid.VERTICAL_SCROLL);
				var remainingColumnsWidth:Number = dataGridColumnsWidth;
				var incrementValue:Number = 0;//as addtion default value 0
				var defaultValue:Number = 200;
				var perecentSymbol:String = "";
				if(removeHorizontalScrollBar.value){
					defaultValue = dataGridColumnsWidth / columnCount;
					perecentSymbol = "%";
				}
				
				if(columnWidths.childListCallbacks.lastObjectRemoved){
					
					var removedSessionedWidth:LinkableString = columnWidths.childListCallbacks.lastObjectRemoved as LinkableString;
					var removedSessionedWidthValue:Number = NumberUtils.getNumberFromNumberOrPercent(removedSessionedWidth.value, dataGridColumnsWidth);
					if(removeHorizontalScrollBar.value){
						incrementValue = removedSessionedWidthValue / columnCount;
					}
					else{
						dataGridColumnsWidth = dataGridColumnsWidth - removedSessionedWidthValue;
						remainingColumnsWidth = dataGridColumnsWidth;
					}
				}
				
				//run the loop reverse
				// so that newly added column comes first
				for (var j:int = _currentDataGridColumns.length-1; j > -1; j--)
				{
					var dgc:WeaveCustomDataGridColumn = _currentDataGridColumns[j] as WeaveCustomDataGridColumn;
					var columnName:String = columns.getName(dgc.attrColumn);
					if (columnName == null)
						continue;
					var sessionedWidth:LinkableString = columnWidths.getObject(columnName) as LinkableString;
					// we don't want to create a sessionedWidth because one will be created later if the column wasn't disposed
					if (sessionedWidth == null)
						continue; 
					var tempWidth:Number;
					if(sessionedWidth.value ){						
						if (columnWidths.childListCallbacks.lastObjectRemoved){
							tempWidth = NumberUtils.getNumberFromNumberOrPercent(sessionedWidth.value, dataGridColumnsWidth) + incrementValue;
							if(removeHorizontalScrollBar.value){								
								sessionedWidth.value = Math.round(100 * (tempWidth / dataGridColumnsWidth)) + perecentSymbol;
							}
							else{
								sessionedWidth.value = tempWidth + perecentSymbol;
							}
						}
						else{
							var oldSessionedValue:Number = NumberUtils.getNumberFromNumberOrPercent(sessionedWidth.value, dataGridColumnsWidth);
							if(remainingColumnsWidth != dataGridColumnsWidth){//when a column is removed
								tempWidth = Math.round(NumberUtils.getNumberFromNumberOrPercent(sessionedWidth.value, remainingColumnsWidth));
								var updatedSessionedValue:Number;
								if(removeHorizontalScrollBar.value){
									var oldSessionedPerecentValue:Number = (100 * oldSessionedValue) / dataGridColumnsWidth;
									updatedSessionedValue = (remainingColumnsWidth/dataGridColumnsWidth) * oldSessionedPerecentValue ;
								}
								else{
									updatedSessionedValue = (remainingColumnsWidth/dataGridColumnsWidth) * oldSessionedValue ;
								}
								sessionedWidth.value = Math.round(updatedSessionedValue) + perecentSymbol;							
							}
							else{
//								if(toolDataGridWidthDiff > 0){
//									oldSessionedValue = oldSessionedValue - ((oldSessionedValue/dataGridColumnsWidth)*toolDataGridWidthDiff);
//								}
								tempWidth = Math.round(oldSessionedValue);
							}	
						}
					}
					else{
						tempWidth = Math.round(defaultValue);
						remainingColumnsWidth = dataGridColumnsWidth - tempWidth;
						sessionedWidth.value = tempWidth + perecentSymbol;
						if(removeHorizontalScrollBar.value){
							sessionedWidth.value = Math.round(100 * (tempWidth / dataGridColumnsWidth)) + perecentSymbol;
						}
						else{
							sessionedWidth.value = tempWidth + perecentSymbol;
						}
						
					}
					
					if (tempWidth <= 5 || isNaN(tempWidth)) {
						tempWidth = _minSuggestedColumnSize;	
					}											
					// always force the width to be the new value
					var newWidth:Number = Math.floor(Math.min(tempWidth, dataGridColumnsWidth));
					dgc.setWidth(newWidth);
					if (dgc.filterComponent){
						dgc.filterComponent.width = newWidth;
					}					
				}
			}
			
			private function handleDataGridScroll():void
			{
				var hsp:int = 0;
				for (var i:int = 0; i < dataGrid.horizontalScrollPosition && i < _currentDataGridColumns.length; i++)
					hsp += (_currentDataGridColumns[i] as WeaveCustomDataGridColumn).width;
				filterControls.horizontalScrollPosition = hsp;
			}
			
			
			private function handleKeyColumnCheckBox():void
			{
				if(showKeyColumnCheckBox.selected)
				{
					var kc:Array= columns.getObjects(KeyColumn);
					if(kc.length == 0)
					{
						var nameOrder:Array = columns.getNames();
						columns.requestObject("KeyColumn",KeyColumn, false);
						columns.setNameOrder(nameOrder);
					}					
					updateKeyTypeComboBox();
					
				}
				else
				{
					var keyCols:Array = columns.getNames(KeyColumn);
					for each(var keyCol:String in keyCols)
					{
						columns.removeObject(keyCol);
					}
				}
				
			}
			
			public const lockedColumns:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0), handleLockedColumnChange, true);
			private function handleLockedColumnChange():void
			{
				if (!parent)
				{
					callLater(handleLockedColumnChange);
					return;
				}
				if (lockedColumns.value < 0 || lockedColumns.value > dataGrid.columns.length)
					lockedColumns.value = 0;
				dataGrid.lockedColumnCount = lockedColumns.value;
			}
			
			
		]]>
	</mx:Script>
	<ui:ControlPanel>
		<mx:VBox id="attributesPanel" label="Attributes for Data Table">
			<ui:ColumnListComponent id="dimensionsList"  backgroundAlpha="0.7" height="100%" width="100%" label="Columns"/>
			<mx:Button label="Add Image Column" click="addImageColumn()" />
			<mx:CheckBox id="showControlsCheckBox" label="Show controls on panel"/>
			<mx:CheckBox id="showFiltersCheckBox" label="Show Filters on panel"/>
			<mx:CheckBox id="showColorsCheckBox" label="Show Colors"/>
			<mx:CheckBox id="removeHScrollBarCheckBox" label="Remove Horizontal Scroll Bar"/>
			<mx:CheckBox change="handleKeyColumnCheckBox()" id="showKeyColumnCheckBox" label="Show Key Column"/>
			<mx:CheckBox label="Export keys with data" creationComplete="linkBindableProperty(exportKeys, event.target, 'selected');"/>
			<mx:Button label="Export Data..." click="exportCSV()" />
			<mx:HBox>
				<mx:Label text="Number of Locked Columns"/>
				<mx:NumericStepper id="numLockedColumns" minimum="0" maximum="{dataGrid.columns.length}" 
								   creationComplete="linkBindableProperty(lockedColumns, event.target, 'value');"/>	
			</mx:HBox>			
		</mx:VBox>
		<editors:WindowSettingsEditor target="{this}"/>
	</ui:ControlPanel>
</ui:DraggablePanel>
